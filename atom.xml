<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Minotaur story]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://minotaursu.com/"/>
  <updated>2018-02-22T06:10:40.215Z</updated>
  <id>http://minotaursu.com/</id>
  
  <author>
    <name><![CDATA[minotaur]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一次GC耗时超长的问题排查]]></title>
    <link href="http://minotaursu.com/2018/02/22/%E4%B8%80%E6%AC%A1GC%E8%80%97%E6%97%B6%E8%B6%85%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://minotaursu.com/2018/02/22/一次GC耗时超长的问题排查/</id>
    <published>2018-02-22T03:57:06.000Z</published>
    <updated>2018-02-22T06:10:40.215Z</updated>
    <content type="html"><![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/gc.png" alt=""></p>
<p>2017年10月某日突然收到FullGC耗时超长的报警，排查发现应用存在周期性FULLGC耗时超长的的情况，每次FULLGC时间长达5s以上，甚至出现过10s以上的FULLGC，导致FULLGC时应用的响应全部超时。 最初是怀疑系统有大量的对象没有释放导致FULLGC时间过长，第一时间dump了应用的内存，并没有发现内存泄露的情况。后面查看GC日志发现Rescan阶段weak refs processing的超时都超长，GC日志里大量可见[weak refs processing, 9.7398650 secs]，排查的方向就逐渐转向了weak refs processing 为什么会花费如此长的时间，按照这个思路排查了一晚上也没有结果。<br>第二天使用<a href="http://gceasy.io/" target="_blank" rel="external">http://gceasy.io/</a> 进行了GC的可视化分析，发现了一个之前一直忽略的现象，GC真实的耗时是远大于用户耗时和系统耗时的，[Times: user=2.56 sys=0.07, real=9.82 secs]。我们知道JVM本身作为一个进程也是由linux系统进行内存分配，而linux的内存空间由两部分构成，物理内存和swap空间，假如GC时有一部分内容被交换到swap，遍历到这部分的时候就需要将其交换回内存，极端情况下甚至会把整个堆分区轮流往SWAP写一遍，而磁盘交换的速度是远慢于物理内存的，如果GC和swap同时发生会导致超长时间的卡顿，通过sar -W -f 命令分析发现swap时间完全吻合发生耗时超长的GC时间，基本可以断定是系统的物理内存不够用导致系统发生swap，最终导致耗时超长的GC发生，关闭linux的swap后引用的GC时间恢复到500ms以下。<br>虽然gc耗时超长的问题得到了解决，但是仔细思考一下就会发现问题的解决完全依赖程序员的推理过程和知识储备，那么是不是可以有更简单更快速的问题排查定位手段，我认为答案是可以的，那就是更加智能化的监控，将业务指标，应用指标，系统指标打通关联，在FULLGC超时报警的时候通知告知业务开发系统发生了swap，并且能展示对订单量和GMV等指标的影响。好的基础设施就像强大的武器，虽然依赖好的枪法用手枪也能杀死敌人，但是手里有把AKM或M16还是更容易吃鸡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/gc.png" alt=""></p>
<p>2017年10月某日突然收到FullGC耗时超长的报警，排查发现应用存在周期性FULLGC耗时超长的的情况，每次FULLGC时间长达5s以上，甚]]>
    </summary>
    
      <category term="gc" scheme="http://minotaursu.com/tags/gc/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jackson使用setDateFormat后反序列化错误]]></title>
    <link href="http://minotaursu.com/2017/12/22/jackson%E4%BD%BF%E7%94%A8setDateFormat%E5%90%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%94%99%E8%AF%AF/"/>
    <id>http://minotaursu.com/2017/12/22/jackson使用setDateFormat后反序列化错误/</id>
    <published>2017-12-22T04:08:57.000Z</published>
    <updated>2017-12-22T04:11:15.181Z</updated>
    <content type="html"><![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/jackson.png" alt=""></p>
<p>最近marketing-activity系统在接入降级服务，出现启动时可以正确获取到降级配置，系统运行一段时间后修改降级策略不生效的问题，之前订单系统，用户系统和其他系统的接入都没问题出现这个问题，肯定是触发了某种特定的case。营销的同学联系我进行排查，排查日志发现是降级服务反序列化Date类型异常，接收到的数据格式是yyyy-MM-dd HH:mm:ss，并不在jackson支持的反序列化格式之内。降级服务的sdk也是使用的jackson进行序列化的，为什么会出现jackson序列化后的数据却不能使用jackson反序列化。<br>接着查看marketing-activity系统的降级服务sdk日志发现一个很诡异的现象，最初发送的序列化后的请求还是时间戳格式的，运行一段时间后就变成了yyyy-MM-dd HH:mm:ss格式，也就是说系统的行为在运行时被改变了。<br><img src="http://hexo-tuchuan.qiniudn.com/sds-log.png" alt=""></p>
<p>那么到底是什么可以改变系统运行时的序列化逻辑呢？可能出现的主要原因有2种。一种是字节码技术，也就是btrace，greys这些。另一种就是调用jackson本身的api改变了一些属性。显然第二种的可能性更大一些，果然在jsonUitl里发现了蛛丝马迹，toObject允许设置特定的时间格式进行反序列化，调用setDateFormat会导致后续全部的Date类型的序列化都会是yyyy-MM-dd HH:mm:ss格式，自然不能默认设置的jackson反序列化。<br><img src="http://hexo-tuchuan.qiniudn.com/jsonutil.png" alt=""></p>
<p>至此降级服务改变策略后不生效的根本原因就得到了解答，那么如果某个对象就是要使用yyyy-MM-dd HH:mm:ss 进行序列化和反序列化怎么办，建议使用@JsonFormat 单独对属性进行注释。<br>最后谈谈fastjson和jackson，貌似jackson的各种坑遇到过很多，而fastjson的坑很少，那么为什么jackson还是要比fastjson更流行，真的只是国外的月亮更圆，空气更甜？这个主要是json框架的设计理念偏重点不同，fastjson偏重的是简单和快速，内部实现有很多的hack和magic code。而jackson偏重的是标准和强大，格式支持json，xml，有很多的属性可以设置非常的灵活，也有很多的接口可以自定义进行扩展，导致学习成本比较高，需要详细看过jackson文档才能上手。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/jackson.png" alt=""></p>
<p>最近marketing-activity系统在接入降级服务，出现启动时可以正确获取到降级配置，系统运行一段时间后修改降级策略不生效的问]]>
    </summary>
    
      <category term="jackson" scheme="http://minotaursu.com/tags/jackson/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="json" scheme="http://minotaursu.com/tags/json/"/>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更换一门工作语言的成本]]></title>
    <link href="http://minotaursu.com/2017/12/18/%E6%9B%B4%E6%8D%A2%E4%B8%80%E9%97%A8%E5%B7%A5%E4%BD%9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://minotaursu.com/2017/12/18/更换一门工作语言的成本/</id>
    <published>2017-12-18T08:21:21.000Z</published>
    <updated>2017-12-22T08:27:42.020Z</updated>
    <content type="html"><![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/lang.jpeg" alt=""></p>
<p>程序员这个职业经常需要学习新的技术，假如某一天工作上主要使用的语言没落了，或者新的项目需要使用另一门不熟悉的语言开发，那么成本到底有多少，那些是需要重新学习的，又有那些是可以被保留或者继承的。</p>
<h3 id="需要重新学习的">需要重新学习的</h3><ol>
<li>语法&amp;语法糖。这应该是最简单的部分，是用大括号分组还是使用缩进分组，条件语句是否需要括号，函数是否可以赋值给变量，是否支持lambda。</li>
<li>语言中的对象&amp;集合。可以看做是更高一级的语法，用来处理数据结构。</li>
<li>怎么处理io&amp;网络&amp;数据库连接。 上点规模的项目必然用到。</li>
<li>经典的第三方库。需要一段时间。</li>
<li>经典的应用框架。使用可能比较快，解决疑难bug和二次开发需要对源码有一定了解。</li>
<li>线程协程。想要写出高效的代码必须精通。</li>
<li>语言相关的中间件。这可能是成本最高，最痛苦的部分。</li>
</ol>
<h3 id="不需要重新学习的">不需要重新学习的</h3><ol>
<li>如何学习一门语言。不开玩笑，这才是最重要的技能，熟悉一门语言后学习新的语言会快很多。</li>
<li>数据结构和算法的知识。</li>
<li>操作系统。</li>
<li>io&amp;网络&amp;数据库方面的知识。</li>
<li>数据库调优。</li>
<li>业务系统设计。</li>
<li>架构思想。MVC分层，微服务。</li>
<li>中间件的原理。</li>
<li>业务知识。</li>
<li>思维逻辑。</li>
</ol>
<p>需要重新学习的主要集中在工具层面，保留的主要是思想和原理。看起来重新学习一门语言就像一个内力深厚的高手不再用剑改学刀法，问题不会很大，但也不是毫无风险，初学期遇到一个难缠的对手也容易乱拳打死老师傅。可能需要一个月到半年的熟悉期。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/lang.jpeg" alt=""></p>
<p>程序员这个职业经常需要学习新的技术，假如某一天工作上主要使用的语言没落了，或者新的项目需要使用另一门不熟悉的语言开发，那么成本到底有多少，]]>
    </summary>
    
      <category term="go" scheme="http://minotaursu.com/tags/go/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="python" scheme="http://minotaursu.com/tags/python/"/>
    
      <category term="语言" scheme="http://minotaursu.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[archsummit2017见闻和思考]]></title>
    <link href="http://minotaursu.com/2017/12/13/archsummit2017%E8%A7%81%E9%97%BB%E5%92%8C%E6%80%9D%E8%80%83/"/>
    <id>http://minotaursu.com/2017/12/13/archsummit2017见闻和思考/</id>
    <published>2017-12-13T10:31:39.000Z</published>
    <updated>2017-12-13T12:45:53.469Z</updated>
    <content type="html"><![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/archsummit.jpeg" alt=""></p>
<p>前几天参加了archsummit的北京站。2天的日程安排的十分紧凑，大多数时间同时有多场专题分享，选择想要听的专题就成了首要的事情，按照感兴趣的，可能用到的，启发思考的原则选择了几场适合自己的专题，这里记录一下大会的见闻和思考。</p>
<h2 id="创新是人类的自信">创新是人类的自信</h2><p><strong>推荐指数：4星</strong><br>王坚博士的演讲作为archsummit的开场show拉开了archsummit的帷幕，开场就提出了一个很大的愿景:开一个会能够让50年以后的人开很多会来讨论，每天在世界上开的各种会议数以千万计，能够到达这种目标的会议真是十年难遇，显然要到达这个目标需要巨大的创新，可能是基础理论层面的创新或是定义了某些原理和标准。接下的分享主题都围绕着年轻，创新，自信，三者是相辅相成的，只有挑战离年轻人更近，未来才会离我们更近。虽然分享的时间很短，可以感受到王坚博士是一个有智慧有趣的人，以及非常的有工程师精神。</p>
<h2 id="算法无处不在：Hulu当今和未来的技术架构">算法无处不在：Hulu当今和未来的技术架构</h2><p><strong>推荐指数：3星</strong><br>hulu讲了算法在视频广告业务的应用，算法如何带来更好的用户体验和更高的收入，接下来讲的人工智能平台是很好的工程实践，如何让算法的实现优化验证更容易，如何让更多的人员参与到这个过程，基础设施的建设能够提高工程生产力，服务于更多的场景，产生更多的价值。</p>
<h2 id="阿里巴巴云化架构创新之路">阿里巴巴云化架构创新之路</h2><p><strong>推荐指数：4星</strong><br>目前系统架构实践层面最流行的就是微服务，而容器技术作为微服务最适合的载体，必然是构建技术大厦最基础的一环，而容器的调度和编排就是皇冠上最闪耀的明珠。从google的borg开始到k8s在开源界的一统天下，通过合理的部署调用节约资源的利用率一直就是重点的研究方向，而阿里的分享也几乎都和混合云相关，资源利用率的提示对拥有海量服务和数据的巨头意义重大，每一点带来的都是真金白银。对于缺少devOps知识的业务开发人员来说，是一个很好的科普专题。</p>
<h2 id="高可用低延时的PayPal风控数据平台">高可用低延时的PayPal风控数据平台</h2><p><strong>推荐指数：3星</strong><br>由于下午没有抢到原本想听的专题的位置，去听了金融应用专题，个人理解金融的最重要的核心之一就是风控，虽然分享的标题中带有风控，但是这个分享和风控的关系真心不大，更多的专注于如果做好一个抽象的数据访问层，以及数据访问层相关的性能优化，分享特别提实施一个完整的性能测试是非常花时间的工作，就个人的工作经历来看也是如此，实际的代码编写在工作中所占的时间并不高，反而需求，设计，各种方面的测试，线上问题排查才是真正占用大部分时间的，如何让不懂技术的人了解，接受，支持这些非编码工作和非业务功能工作所占用的大量时间的确是一个问题。</p>
<h2 id="陆金所金融平台的架构大升级">陆金所金融平台的架构大升级</h2><p><strong>推荐指数：2星</strong><br>分享的主题核心也和金融的关系不大，架构演进遇到的问题也是和非金融系统大部分相近，更像是一个做的业务是金融相关的系统的架构演进过程。如果能在更高的维度进行抽象，提炼出分布式系统的关键技术点可能效果会更好。</p>
<h2 id="腾讯海外计费系统架构演进">腾讯海外计费系统架构演进</h2><p><strong>推荐指数：5星</strong><br>腾讯的国际化架构分享干货满满，很多在同一个IDC内的解决方案在，多中心的情况下都没办法采用。针对网络，部署，支付，风控等很多领域的遇到的问题和解决方案多有涉及，可以看到是一个global team在做的事情和相应的技术实力。</p>
<h2 id="京东国际独立站系统演进">京东国际独立站系统演进</h2><p><strong>推荐指数：2星</strong><br>如果说陆金所金融平台的架构大升级是披着金融的外衣讲架构演进，那么京东国际独立站系统演进就是披着国际化的外衣讲架构演进，分享的内容更多是所做的业务是什么样的，并没有提及国际化的技术痛点，最后的性能支撑靠堆机器也是更像玩笑，在一个努力提高服务器资源利用率的时代，真的要这么诚实吗。。</p>
<h2 id="知乎_feed_流架构演进">知乎 feed 流架构演进</h2><p><strong>推荐指数：4星</strong><br>重点在于redis module功能带来的更多可能性，IO和网络操作都变成全内存操作的确大大提高了系统的响应速度。这种底层架构选择的变革带来的收益在适合的场景下具有超高的性价比。</p>
<h2 id="不改一行代码提升系统的性能和稳定性并支持秒杀：看分布式服务化架构关键技术">不改一行代码提升系统的性能和稳定性并支持秒杀：看分布式服务化架构关键技术</h2><p><strong>推荐指数：5星</strong><br>左耳朵耗子的分享真是人气爆棚，刚刚吃完午饭回去就已经座无虚席了，高度的抽象了系统架构领域遇到的问题，核心技术点，信息量很大，这场分享让我觉得很值得archsummit的票价。最后的不改一行代码支持秒杀也很有些诡计和魔术的意味。另外左耳朵耗子对PHP是最好的语言持有不同的看法，日常中个人也觉得java用来做需要持续迭代的业务，python用来做造测试数据和数据分析，shell用来查询线上问题是个很方便的组合。</p>
<h2 id="Service_Mesh在华为云的实践">Service Mesh在华为云的实践</h2><p><strong>推荐指数：3星</strong><br>Service Mesh作为下一代微服务的概念被Linkerd提出，在更底层的软件架构中解决微服务的痛点，分享对比了传统的(当前的)微服务框架和service mesh的优缺点，不难想到这种底层的通用框架面临的比较大的问题就是性能和扩展性，在service mesh的发展中如何解决这2点，发挥底层框架应用透明的优势，做到多数场景的可用就是关键。service mesh不一定是下一代微服务解决方案的结果，但service mesh的思想肯定会在下一代的微服务中传承，Keep it Simple and Stupid。</p>
<h2 id="Apollo自动驾驶及跟车方案的设计思路">Apollo自动驾驶及跟车方案的设计思路</h2><p><strong>推荐指数：4星</strong><br>对我来说有又一场科普向的分享，虽说对工作的帮助不大，但是自己还是很喜欢去听一听的，毕竟人生的一大乐趣就是做无意义的事情。<br>分享人孔旗在百度做主要做预测/决策/控制部分，分享的重点也是这些，很多自动驾驶的问题解决都是抽象出一个可解的数学问题，再对这个问题做简化和降维，得出一个局部最优解。整体听下来，自动驾驶是未来的一个必然，而真正达到L4级别的可用性并不是最近2年就可以搞定的但也不会等的特别久。而自动驾驶绝对是一个大生意，诞生出google，apple这个级别的公司也不奇怪。</p>
<h2 id="说些什么">说些什么</h2><p>互联网的发展史， 从最初的单项传播信息的门户模式 到搜索引擎，微博这种线上双向信息互动的模式，到现在如火如荼的各类各种移动互联网，到高速发展的人工智能和云计算。整体的业务，架构越来越复杂，越来越向着技术密集，资本密集方向发展<br>。对于创业者来说，一方面要面对可能的来自BAT的业务同质化竞争威胁，一方面拥有着BAT深耕出的互联网环境带来的便利，如何找到合适的切入方向就是首要解决的问题。对于互联网研发人员说来，业务复杂度，规模与高可用带来的挑战越来越高，同时开源社区的蓬勃发展也带来了越来越多的可能性，怎样利用好开源资源解决自身的业务问题也变得更加重要。如何在一个知识大爆炸的时代保持独立思考，选择适合自己的方向终将成为重要的技能之一，乔教主的那句 Stay Hungry,Stay Foolish 也许就是最好的解答。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://hexo-tuchuan.qiniudn.com/archsummit.jpeg" alt=""></p>
<p>前几天参加了archsummit的北京站。2天的日程安排的十分紧凑，大多数时间同时有多场专题分享，选择想要听的专题就成了首要的]]>
    </summary>
    
      <category term="Cloud native" scheme="http://minotaursu.com/tags/Cloud-native/"/>
    
      <category term="archsummit" scheme="http://minotaursu.com/tags/archsummit/"/>
    
      <category term="系统设计" scheme="http://minotaursu.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微信红包的设计实现]]></title>
    <link href="http://minotaursu.com/2017/04/27/%E8%B0%88%E8%B0%88%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>http://minotaursu.com/2017/04/27/谈谈微信红包的设计实现/</id>
    <published>2017-04-27T07:19:48.000Z</published>
    <updated>2017-04-28T05:15:30.000Z</updated>
    <content type="html"><![CDATA[<p>红包功能的设计实现是一个很有趣的话题，主要的功能是P个人抢总金额M的N个红包，满足先抢的N个人能抢到红包。如果这是一个leetcode的算法题目难度应该是easy，只要保证Ni抢到的金额区间在[0.01,2倍剩余金额平均值）就能ac。<br>将算法带入到真实的工程实现，问题就要复杂得多，如果达到微信的量级，明显要考虑的有以下几点。</p>
<ol>
<li>拆红包</li>
<li>高并发读</li>
<li>并发写</li>
<li>网络流量峰值</li>
<li>对账</li>
<li>降级</li>
<li>故障恢复</li>
</ol>
<h1 id="拆红包">拆红包</h1><p>拆红包有预拆包和实时拆包2种策略</p>
<h2 id="预拆包策略">预拆包策略</h2><p>预拆包的策略在发红包时将金额M的红包拆分成N份，将分配好的结果放入内存队列或者cache，通过incr操作在用户抢红包时分配预算好的红包slot，预算的策略可以避免对共享资源的操作，减少了锁竞争，服务本身是无状态的，设计和实现相对简单，伸缩性较好。劣势是需要额外的存储空间，如果存在大量活跃红包或者红包份数很多时会增加成本。</p>
<h2 id="实时拆包">实时拆包</h2><p>实时拆包的策略在用户抢红包时实时拆包计算金额，这样只需要保存剩余红包数量和金额，不需要额外保存每个预拆包的红包金额。使用预拆包的策略会面临并发写的问题，如果多个拆红包的请求同时执行会导致数据不一致引起超发的问题，可以使用CAS操作实现乐观锁保证并发拆包不会出现问题。</p>
<h1 id="高并发读">高并发读</h1><p>应对高并发读的通常思路是业务层拦截过滤无效请求，使用有效的缓存。可以使用Cache层decr功能记录请求红包的用户数，当decr到0后就拦截后面的请求直接返回，对DAO层也要增加相应的缓存减少数据库的压力。</p>
<h1 id="并发写">并发写</h1><p>应对并发写的通常思路是串行化和乐观锁。在用户抢红包时实时拆包计算金额，每抢到一个红包，就cas更新剩余金额和红包个数，同时在DB中记录凭证，考虑到DB的写入压力，需要做分库分表，冷热分离。</p>
<h1 id="网络流量峰值">网络流量峰值</h1><p>大量用户同时抢红包是否会造成网络拥塞，发红包和抢红包最好在同一个IDC。</p>
<h1 id="对账">对账</h1><p>考虑到拆红包凭证和入账是异步的2套系统，以及出现故障的可能，需要定时对账保证数据的一致性。</p>
<h1 id="降级">降级</h1><p>在cache故障时有限流的使用DB进行服务，在资源紧张的时候关闭掉非核心流程，在实时入账请求量过大时，延迟批量入账。</p>
<p><img src="http://hexo-tuchuan.qiniudn.com/wechat-small.jpg" alt=""><br>Reference:<br><a href="https://www.zybuluo.com/yulin718/note/93148" target="_blank" rel="external">https://www.zybuluo.com/yulin718/note/93148</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>红包功能的设计实现是一个很有趣的话题，主要的功能是P个人抢总金额M的N个红包，满足先抢的N个人能抢到红包。如果这是一个leetcode的算法题目难度应该是easy，只要保证Ni抢到的金额区间在[0.01,2倍剩余金额平均值）就能ac。<br>将算法带入到真实的工程实现，问题]]>
    </summary>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="开发" scheme="http://minotaursu.com/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="系统设计" scheme="http://minotaursu.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用AOP记录应用调用链开销]]></title>
    <link href="http://minotaursu.com/2017/04/12/%E4%BD%BF%E7%94%A8AOP%E8%AE%B0%E5%BD%95%E5%BA%94%E7%94%A8%E8%B0%83%E7%94%A8%E9%93%BE%E5%BC%80%E9%94%80/"/>
    <id>http://minotaursu.com/2017/04/12/使用AOP记录应用调用链开销/</id>
    <published>2017-04-12T04:47:04.000Z</published>
    <updated>2017-04-12T05:14:39.000Z</updated>
    <content type="html"><![CDATA[<p>最近系统出现了一次线上的性能问题，本来以为目前的QPS应该是不会出现任何问题的，结果微服务还是比较容易因为某个点的问题导致雪崩的。。。出了性能问题就要做分析，正统的思路是要不断进行压测用JProfiler进行分析。后来自己简单搞了一下使用AOP抓取调用树和开销，看起来效果还不错，加上动态开关可以偶尔在线上用一下。代码提交到了<a href="https://github.com/minotaursu/profilerAop" target="_blank" rel="external">github</a>。本身的实现类似树的深度优先遍历，一个节点有多个子节点，在进入方法之前enter，在退出方法后release，都被release了就可以打印调用树日志了。而webx的profiler本身就提供了这种实现，大大的减少了开发时间。虽然之前在使用webx的时候总是觉得不爽，没有springmvc来的简洁，layout,action,screen也不适合移动时代的开发，现在都是rest服务或者使用api gateway配置api了，但不得不说webx的很多思想还是值得深入学习的，很多工具也很适合开源使用。一个框架能够稳定运行在各种业务场景，大范围推广使用本身就是了件不起的事情，这里给webx点个赞。<br>最后来看一下profiler的demo效果。<br><img src="http://hexo-tuchuan.qiniudn.com/profiler.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近系统出现了一次线上的性能问题，本来以为目前的QPS应该是不会出现任何问题的，结果微服务还是比较容易因为某个点的问题导致雪崩的。。。出了性能问题就要做分析，正统的思路是要不断进行压测用JProfiler进行分析。后来自己简单搞了一下使用AOP抓取调用树和开销，看起来效果还]]>
    </summary>
    
      <category term="AOP" scheme="http://minotaursu.com/tags/AOP/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="spring" scheme="http://minotaursu.com/tags/spring/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年终总结]]></title>
    <link href="http://minotaursu.com/2017/04/06/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://minotaursu.com/2017/04/06/2016年终总结/</id>
    <published>2017-04-06T11:38:08.000Z</published>
    <updated>2018-02-22T02:22:49.450Z</updated>
    <content type="html"><![CDATA[<p>在2017年过去小半年之后，还是决定回顾一下过去的2016，写了这个年终总结。2016年初拿到了驾照，装修好了房子，看着勇士在总决赛被逆转痛失冠军，在G20期间出去玩了一趟，算是2016年比较重要的几件事情。 工作上运维了一整年的elasticsearch，支持了后台和BI的部分业务，贡献了大量的代码，也重构了很多的代码。在工作2年之后对系统大部分功能都比较熟悉，心理感觉有些疲倦，代驾也是一个拼内功，拼服务的行业，少会有爆发式的增长，市场的空间清晰可见。年后去前东家的云计算部门面试了一趟，希望能争取一个满意的offer，前东家给了一个base提升了一些，但算上滴滴的未固化的期权是降薪的offer。对于这种变化不大的offer最是难以选择，考虑了很久纠结了很久，最后还咨询了很多前同事的意见，大部分人是不建议我去。 工作上，行业，部门，老板，薪水都满意的情况实在难以出现。总体来说，2016年是变好的一年，并没有多少糟心的事情，日子很平静。2017年对自己的期待就是空杯心态，精益求精吧。</p>
<p>2017·wishlist</p>
<ol>
<li>日本/九寨沟行一次，目的地视财力而定</li>
<li>为知名开源项目贡献一次代码，例如elasticsearch，netty等</li>
<li>完成 <a href="http://book.douban.com/people/49806902/wish" target="_blank" rel="external">豆瓣阅读列表</a></li>
<li>blog的最高uv到达100</li>
<li>改进计费系统的持续集成方案</li>
<li>2017年总结时，列出一件自己觉得NB的事情</li>
</ol>
<p><img src="http://hexo-tuchuan.qiniudn.com/cup.jpeg" alt="空杯心态,精益求精"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在2017年过去小半年之后，还是决定回顾一下过去的2016，写了这个年终总结。2016年初拿到了驾照，装修好了房子，看着勇士在总决赛被逆转痛失冠军，在G20期间出去玩了一趟，算是2016年比较重要的几件事情。 工作上运维了一整年的elasticsearch，支持了后台和BI]]>
    </summary>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="滴滴" scheme="http://minotaursu.com/tags/%E6%BB%B4%E6%BB%B4/"/>
    
      <category term="阿里" scheme="http://minotaursu.com/tags/%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[消息队列之简要设计]]></title>
    <link href="http://minotaursu.com/2016/11/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8B%E7%AE%80%E8%A6%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://minotaursu.com/2016/11/06/消息队列之简要设计/</id>
    <published>2016-11-06T02:03:36.000Z</published>
    <updated>2017-03-07T05:39:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="消息队列的基本功能">消息队列的基本功能</h2><p>消息队列作为系统解耦，流量控制的利器，成为分布式系统核心组件之一。在日常的开发我们享受了使用消息队列带来的便利，那么如果要自己实现一个消息队列应该入手。本文不深入讨论具体，成熟的消息队列如kafka，rocketmq等，主要介绍一下基本功能，思想和设计。<br>首先转换一下角色，作为产品经理给自己提出一个实现消息队列的需求，那么首先列一下消息队列必备的功能有哪些。</p>
<ul>
<li>消息堆积</li>
<li>消息持久化</li>
<li>消息顺序</li>
<li>消息最少投递一次</li>
<li>支持多topic</li>
<li>相同topic支持多consumer</li>
<li>消息回溯</li>
<li>集群功能</li>
<li>负载均衡</li>
</ul>
<p>一个简单的消息队列基本功能如上，在某些特殊的场景还需要支持事务，消息重试等功能。此外除了功能部分，还需要尽可能优化性能，提供监控功能帮助报警和排查问题。</p>
<h2 id="消息队列的设计实现">消息队列的设计实现</h2><p>明确了功能需求，接下来就要考虑如何实现一个消息列队。<br>消息队列主要涉及到三个部分，通信协议+存储+消费关系维护。</p>
<h4 id="通信协议">通信协议</h4><p>极简版的消息队列甚至只需要一个redis就可以，按照topic将序列化的数据存储到redis，消费端使用redis的incr功能获取锁，获取到锁的consumer不断的轮询获取消息。当然这种极简版的消息队列是不能通过复杂的生产环境检验的，系统的可靠性也不能保证。这里将极简版的消息队列升级一下，使用成熟的RPC框架实现通信协议，将一次同步RPC调用变成2次PRC+存储，PRC框架帮我们解决了负载均衡，服务发现，通信协议，序列化/反序列化等问题。同时RPC框架也保证了通信层面的高可用。</p>
<h4 id="存储选择">存储选择</h4><p>对于分布式系统，存储的选择有以下几种</p>
<ul>
<li>内存</li>
<li>本地文件系统</li>
<li>分布式文件系统</li>
<li>nosql</li>
<li>rdbms<br>从速度上内存显然是最快的，对于允许消息丢失，消息堆积能力要求不高的场景(例如日志)，内存会是比较好的选择。rdbms则是最简单的实现可靠存储的方案，很适合用在可靠性要求很高，最终一致性的场景(例如交易消息)，对于不需要100%保证数据完整性的场景，要求性能和消息堆积的场景，hbase也是一个很好的选择。</li>
</ul>
<h4 id="消费关系">消费关系</h4><p>在消息存储在broker上后，需要的就是将消息正确的投递到消费者，消息的投递分为广播和单播, 最常见的使用场景是组内单播，组间广播，同一个集群使用相同的group注册订阅，通常消息队列本身不维护消费订阅关系，使用例如zookeeper等成熟的系统维护消费关系，在消费关系发生变化时下发通知。</p>
<h2 id="队列特性">队列特性</h2><p>确定了消息队列的模块功能需求后，还需要考虑队列的特性需求，这里重点考虑消息丢失，消息确认，消息重复，消息顺序性，投递方式</p>
<h4 id="消息丢失">消息丢失</h4><p>消息丢失可能发生在3种情况</p>
<ul>
<li>生产者-&gt; 队列</li>
<li>队列-&gt; 消费者</li>
<li>队列持久化本身<br>在生产者产生消息到队列的过程可能由于网络问题，宕机等原因没有达到消息队列，或者到达队列后并没有返回消息，这时可以通过重试等方式解决。队列到消费者时也会存在同样的问题，可以通过增加一个标识，投递消息前先标记成待完成状态，在收到消费者确认成功的回复后标记成完成。可以看到消息丢失和消息重复是一个硬币的2面, 保证消息不丢失也会带来消息重复的问题。</li>
</ul>
<h4 id="消息确认">消息确认</h4><p>消息确认就是将2次RPC变成3次RPC。在某些场景默认auto ack是可以的，但也需要支持消息者主动ack，在之后的某个时间重新投递</p>
<h4 id="消息重复">消息重复</h4><p>上面提到，在需要保证消息不丢失的场景，因为对投递失败的情况不可确定是失败，还是超时，需要进行重发，一定会带来消息的重复，这里要考虑的是如何减少重复，可以根据一定的规则(业务id+业务名)，数据库唯一主键，分布式主键等产生messageId（为了方便排查问题，一定要有messageId）, 对比清除周期内记录的messageId，如果messageId相同就认为是重复的消息。</p>
<h4 id="消息顺序性">消息顺序性</h4><p>比较简单有效的实现消息顺序性的方式就是单线程生产者+单线程消费者+每个消费线程对应一个单独队列, 排除消息丢失的情况，可以做到严格有序。</p>
<h4 id="投递方式">投递方式</h4><p>消息队列的投递方式可以分为push和pull2种，一种模型的某些场景下的优点，在另一些场景就可能是缺点。无论是push还是pull，都存在各种的利弊。<br>push的优点就是及时性，缺点就是受限于消费者的消费能力，可能造成消息的堆积，broker会不断给消费者发送不能处理的消息。<br>pull的优点的就是主动权掌握在消费方，可以根据自己的消息速度进行消息拉取，缺点就是消费方不知道什么时候可以获取的最新的消息，会有消息延迟和忙等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="消息队列的基本功能">消息队列的基本功能</h2><p>消息队列作为系统解耦，流量控制的利器，成为分布式系统核心组件之一。在日常的开发我们享受了使用消息队列带来的便利，那么如果要自己实现一个消息队列应该入手。本文不深入讨论具体，成熟的消息队列如kafka，rock]]>
    </summary>
    
      <category term="分布式" scheme="http://minotaursu.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="消息队列" scheme="http://minotaursu.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="软件开发" scheme="http://minotaursu.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty详解之reactor模型]]></title>
    <link href="http://minotaursu.com/2016/09/23/netty%E8%AF%A6%E8%A7%A3%E4%B9%8Breactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://minotaursu.com/2016/09/23/netty详解之reactor模型/</id>
    <published>2016-09-23T09:41:41.000Z</published>
    <updated>2017-02-23T03:39:30.000Z</updated>
    <content type="html"><![CDATA[<p>假设在办理各种证件时分为填表，审核，制作3个过程，每个过程用时10分钟，这样一个工作人员需要30分钟办理一个证件。那么有没有办法提供效率，减少等待时间呢。可以让一个专门的工作人员，每个顾客到来时就负责让顾客填表，在顾客填好表后交给其他工作人员审核。这样其他功能人员的工作效率就从30分钟提高到了20分钟。</p>
<h2 id="Reactor模式">Reactor模式</h2><p>Reactor模式就是这样一种机制，利用事件驱动减少工作线程的等待时间。Reactor模式是处理并发I/O比较常见的一种模式，用于同步I/O，中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上；一旦有I/O事件<strong>准备就绪</strong>(区别在于多路复用器是边沿触发还是水平触发)，多路复用器返回并将相应I/O事件分发到对应的处理器中。</p>
<h2 id="单线程模型">单线程模型</h2><p>这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。 </p>
<p><img src="http://hexo-tuchuan.qiniudn.com/reactor3.png" alt=""></p>
<h2 id="多线程模型（单Reactor）">多线程模型（单Reactor）</h2><p>相比上一种模型，该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。 </p>
<p><img src="http://hexo-tuchuan.qiniudn.com/reactor4.png" alt=""></p>
<h2 id="多线程模型（多Reactor）">多线程模型（多Reactor）</h2><p>这个模型比起第二种模型，它是将Reactor分成两部分，mainReactor负责监听并accept新连接，然后将建立的socket通过多路复用器（Acceptor）分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据；业务处理功能，其交给worker线程池完成。通常，subReactor个数上可与CPU个数等同。</p>
<p><img src="http://hexo-tuchuan.qiniudn.com/reactor5.png" alt="">  </p>
<h2 id="服务端通信时序">服务端通信时序</h2><p><img src="http://hexo-tuchuan.qiniudn.com/reactor1.png" alt="服务端通信序列图"></p>
<h2 id="客户端通信时序">客户端通信时序</h2><p><img src="http://hexo-tuchuan.qiniudn.com/reactor2.png" alt="客户端通信序列图"></p>
<p>Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设在办理各种证件时分为填表，审核，制作3个过程，每个过程用时10分钟，这样一个工作人员需要30分钟办理一个证件。那么有没有办法提供效率，减少等待时间呢。可以让一个专门的工作人员，每个顾客到来时就负责让顾客填表，在顾客填好表后交给其他工作人员审核。这样其他功能人员的工作效率]]>
    </summary>
    
      <category term="io" scheme="http://minotaursu.com/tags/io/"/>
    
      <category term="netty" scheme="http://minotaursu.com/tags/netty/"/>
    
      <category term="reactor" scheme="http://minotaursu.com/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netty详解之io模型]]></title>
    <link href="http://minotaursu.com/2016/09/23/netty%E8%AF%A6%E8%A7%A3%E4%B9%8Bio%E6%A8%A1%E5%9E%8B/"/>
    <id>http://minotaursu.com/2016/09/23/netty详解之io模型/</id>
    <published>2016-09-23T08:12:54.000Z</published>
    <updated>2017-02-23T03:38:43.000Z</updated>
    <content type="html"><![CDATA[<p>提起IO模型首先想到的就是同步，异步，阻塞，非阻塞这几个概念。每个概念的含义，解释，概念间的区别这些都是好理解，这里深入*nix系统讲一下IO模型。  </p>
<p>在*nix中将IO模型分为5类。  </p>
<ol>
<li>Blocking I/O   </li>
<li>Nonblocking I/O  </li>
<li>I/O Multiplexing (select and poll)  </li>
<li>Signal Driven I/O (SIGIO)  </li>
<li>Asynchronous I/O (the POSIX aio_functions)  </li>
</ol>
<h2 id="阻塞_I/O（blocking_IO）">阻塞 I/O（blocking IO）</h2><p><img src="http://hexo-tuchuan.qiniudn.com/bio.png" alt=""></p>
<p>如图所示，系统调用recvfrom，内核kernel等待数据数据准备完成，在数据准备完成后将数据从内核态拷贝到用户态，recvfrom直到整个过程结束后才完成，在整个过程中经历2次阻塞。</p>
<h2 id="非阻塞_I/O（nonblocking_IO）">非阻塞 I/O（nonblocking IO）</h2><p><img src="http://hexo-tuchuan.qiniudn.com/nio.png" alt=""></p>
<p>如图所示，系统调用recvfrom，内核kernel在数据没有准备完成时直接返回，系统会不断轮询，在kernel准备完成数据后将数据从内核态拷贝到用户态，在等待数据完成的过程中并不阻塞。</p>
<h2 id="I/O_多路复用（_IO_multiplexing）">I/O 多路复用（ IO multiplexing）</h2><p><img src="http://hexo-tuchuan.qiniudn.com/mio.png" alt=""></p>
<p>如图所示，IO multiplexing 使用select，poll，epoll等实现单个kernel的进程/线程处理多个IO请求，IO复用将等待数据准备和将数据拷贝给应用这两个阶段分开处理，让一个线程（而且是内核级别的线程）来处理所有的等待，一旦有相应的IO事件发生就通知继续完成IO操作，虽然仍然有阻塞和等待，但是等待总是发生在一个线程，这时使用多线程可以保证其他线程一旦唤醒就是处理数据。</p>
<h2 id="信号驱动_I/O_(Signal_Driven_I/O)">信号驱动 I/O (Signal Driven I/O)</h2><p><img src="http://hexo-tuchuan.qiniudn.com/sio.png" alt=""></p>
<p>如图所示，系统调用recvfrom试图读取数据，并且直接返回，不管是否有数据可读，内核线程读完数据，给发信号通知应用线程，应用线程收到信息，等待内核线程将数据拷贝给应用线程。</p>
<h2 id="异步_I/O（asynchronous_IO）">异步 I/O（asynchronous IO）</h2><p><img src="http://hexo-tuchuan.qiniudn.com/aio.png" alt=""></p>
<p>如图所示，系统调用aio_read，内核kernel直接返回，系统不需要阻塞，继续做其他事情。kernel则进行等待数据准备完成，并将数据拷贝到用户态后，发送signal信号通知系统已经完成。</p>
<h2 id="各个IO模型的对比">各个IO模型的对比</h2><p><img src="http://hexo-tuchuan.qiniudn.com/dio.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>提起IO模型首先想到的就是同步，异步，阻塞，非阻塞这几个概念。每个概念的含义，解释，概念间的区别这些都是好理解，这里深入*nix系统讲一下IO模型。  </p>
<p>在*nix中将IO模型分为5类。  </p>
<ol>
<li>Blocking I/O   </li>
]]>
    </summary>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="netty" scheme="http://minotaursu.com/tags/netty/"/>
    
      <category term="nio" scheme="http://minotaursu.com/tags/nio/"/>
    
  </entry>
  
</feed>
