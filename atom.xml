<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Minotaur story]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://minotaursu.com/"/>
  <updated>2019-05-16T12:13:21.798Z</updated>
  <id>http://minotaursu.com/</id>
  
  <author>
    <name><![CDATA[minotaur]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我对未来技术趋势的一些看法]]></title>
    <link href="http://minotaursu.com/2019/05/16/%E6%88%91%E5%AF%B9%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/"/>
    <id>http://minotaursu.com/2019/05/16/我对未来技术趋势的一些看法/</id>
    <published>2019-05-16T09:40:27.000Z</published>
    <updated>2019-05-16T12:13:21.798Z</updated>
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/skycity.jpg" alt=""><br>预测未来的技术发展方向是件有趣又有意义的事情，正确的判断技术发展方向对于技术选型，业务发展和职业规划都起着至关重要的作用。日常的需求沟通，项目管理，设计编码，运维部署工作能带给我们满足感和安全感，但是在脚踩大地之外偶尔也需要仰望一下星空，看看未来是什么样子，这里就神棍一把，说一下我对未来技术发展趋势的一些看法。</p>
<h1 id="困难与挑战">困难与挑战</h1><p>在预测未来之前，首先分析一下程序员的日常工作中遇到哪些困难与挑战。</p>
<h3 id="需求和设计">需求和设计</h3><p>在需求沟通阶段，程序员需要准确的获取PRD上的需求信息，并对业务的价值和发展有一定的预判。根据以上的信息进行技术选型，数据建模，设计抽象。在这个过程中主要的挑战有：</p>
<ul>
<li>高效的需求沟通</li>
<li>合理的技术方案选择</li>
<li>对现实世界的逻辑抽象</li>
</ul>
<h3 id="开发和测试">开发和测试</h3><p>在编码和测试阶段，程序员需要选择适合的数据结构并编写算法，合理的运用设计模式高效的实现功能，并且保证尽可能少的存在bug。在这个过程中主要的挑战有：</p>
<ul>
<li>高效的编码</li>
<li>避免语言的陷阱</li>
<li>尽量少的bug</li>
<li>代码有可读性和机器执行效率</li>
</ul>
<h3 id="部署和运维">部署和运维</h3><p>在部署和运维阶段涉及到测试环境和生产环境2个方面，程序员分别需要在测试环境和生产环境部署代码和定位问题。在这个过程中主要的挑战有：</p>
<ul>
<li>方便的提供多套隔离的测试环境</li>
<li>方便的在多集群多机器的生产环境部署和回滚代码</li>
<li>方便的部署和升级基础设施(例如mysql)</li>
<li>生产环境和测试环境的一致</li>
<li>生产环境可以弹性伸缩</li>
<li>有工具能辅助发现定位问题</li>
</ul>
<h3 id="系统内部">系统内部</h3><p>系统内部的主要挑战来自代码腐烂和功能复用2个方面。</p>
<ul>
<li>代码腐烂：如何在系统复杂度不断增加，几千几万次迭代之后依然可以高效的进行功能开发，而不是系统变成谁都不敢动的层层叠，开发效率越来越慢。</li>
<li>功能复用：代码和系统的复用往往意味着更高的开发效率，更少的系统风险，一次修改就可以解决问题，而不是满世界的查找相同功能的代码进行修改。</li>
</ul>
<h3 id="系统外部">系统外部</h3><p>系统外部的主要挑战来自高并发，高并发带来3个问题，抗压，竞态条件，热点数据</p>
<ul>
<li>抗压<br>高并发意味着系统需要支撑更高的吞吐量，如果存在比较严重的性能瓶颈往往导致服务的不可用，无状态的节点可以比较容易的水平扩展，有状态的节点通常会成为系统的瓶颈。比较常见的解决方案是分库分表+缓存，但是同样带来开发难度提升，数据不一致，数据迁移等问题。</li>
<li>竞态条件<br>高并发也会导致小概率的竞态条件不断出现，导致不能得到正确的结果。例如cache aside模式中读缓存为空并且DB读耗时&gt;DB写耗时会导致缓存脏数据问题。</li>
<li>热点数据<br>高并发在秒杀等场景中也会导致热点数据问题，在DB中会导致严重的锁冲突性能急剧下降，在cache中会导致缓存穿透，击穿，雪崩等问题。</li>
</ul>
<h3 id="业务约束">业务约束</h3><p>不同业务的特点也会带来不一样的挑战，例如很多金融业务会要求强一致而非最终一致，计费等业务的错误容忍度也远低于社区，微博突发热点话题的业务特点也会带来更大的技术挑战。</p>
<h1 id="趋势：一切皆代码，无处不AI">趋势：一切皆代码，无处不AI</h1><p>分析了软件开发过程中面临的困难与挑战之后，终于来到了激动人心的未来技术趋势部分。无论是大到工业革命还是小到技术微创新，本质上都会发展生产力，解放生产力，未来技术的发展肯定也会极大的改变软件开发行业，和其他的行业一样，分化成标准化，规划化，规模化的大规模工业制成品模式和少部分知识密集型的研发模式。对于未来的技术趋势我认为是—<strong>一切皆代码，无处不AI</strong>，软件开发的整个生命周期都通过代码的形式进行组织和编排，同时有AI参与到需求，设计，编码，测试，运维的每个阶段，软件开发变的非常容易，极大的降低门槛。 针对上述遇到的困难与挑战，具体看一下已经出现的和可能出现的解决方案。</p>
<h3 id="需求与设计">需求与设计</h3><p>在需求和设计阶段我认为未来的趋势是<strong>SaaS的繁荣+专家系统+更快的原型构建工具</strong>。随着云计算的发展，数据的积累和SaaS自身发展，SaaS会逐步取代外包软件研发和自建研发团队，直接购买SaaS服务将会是中小型公司的第一选择。AI+SaaS会改变SaaS千篇一律的缺点，专家系统根据企业的业务特点生成个性化，定制化，智能化的解决方案。在原型构建领域会出现类Sql的语言，程序员不必再告诉计算机怎么做，只需要声明式编程即可。</p>
<h3 id="编码和测试">编码和测试</h3><p>在编码和测试阶段我认为未来的趋势是<strong>更简单的并发编程+所见即所得编程+AI辅助编程+持续集成</strong>。在未来TDD会成为主流，写单元测试不再是一项增加成本的额外工作，而且真正成为提高生产力的工具，在所见即所得的编程模式中写的每写一行代码都能直接看到单元测试的运行过程和当前结果，AI辅助编程会使得未来实现一个模块就如同当前调用一个类库一样简单，每次的commmit都会触发独立的持续集成流程，软件的开发难度会有大幅下降，开发效率会有极大的提升。</p>
<h3 id="部署和运维-1">部署和运维</h3><p>在部署和运维领域我认为未来的趋势是<strong>容器+AI+故障自动定位+故障转移/恢复</strong>。在高可用架构下人往往成为最大的瓶颈，从故障发生到故障发现到故障定位到故障止损到根因分析，即使有着最强大的监控工具和最高效的处理流程大部分故障依然需要人的介入，故障恢复时间也存在极大的不确定性，同时7✖24的oncall也给人带来极大的精神压力。故障的定位本质上是一个封闭的领域，非常适合机器学习在故障定位中发挥作用，在未来代码部署之后AI就开始学习，当故障发生时可以自动扩容+限流+降级+定位根因+故障转移，甚至可以自动的打一段代码补丁快速止损。</p>
<h3 id="架构">架构</h3><p>在架构领域我认为未来的趋势是<strong>更丰富更强大更智能的基础设施+更强大更智能程序运行时</strong>。软件开发生命周期中技术发展带来的生产力提升将使代码实现更加的简单，风格更加的统一，大幅减少了代码腐烂的速度，提高代码了代码复用率。也一定会出现更强大更智能的runtime环境，使得程序的并发控制更加的简单出错的可能性更小，非功能需求更加容易解决，同时基础设施也会更丰富更强大更智能，更好的解决系统内部，系统外部，业务约束带来的挑战。例如同时满足高性能+高吞吐+事务+扩展性的数据库（关系型并不是OLTP的核心需求）会取代mysql分库分表+缓存的模式。</p>
<h1 id="未来的分化">未来的分化</h1><p>虽然完全的自动编程并不现实（准确的告诉机器想要什么并不比告诉机器如何做更容易），但是生产力的不断发展必然影响这个行业，上述的改变很有可能发生，在未来初级程序员工作会大幅的减少，偏重业务与偏重基础技术的工作也会出现明显的分化，偏业务方向的程序员工作会变成行业解决方案架构师和技术咨询，偏基础技术的程序员则会成为某个领域的专家。</p>
<blockquote>
<p>第一只猴子开始仰望星空时，人类诞生。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/skycity.jpg" alt=""><br>预测未来的技术发展方向是件有趣又有意义的事情，]]>
    </summary>
    
      <category term="架构" scheme="http://minotaursu.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="系统" scheme="http://minotaursu.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="职业规划" scheme="http://minotaursu.com/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
      <category term="设计" scheme="http://minotaursu.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="软件开发" scheme="http://minotaursu.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java保留小数点后2位格式化问题]]></title>
    <link href="http://minotaursu.com/2019/04/29/java%E4%BF%9D%E7%95%99%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E2%E4%BD%8D%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>http://minotaursu.com/2019/04/29/java保留小数点后2位格式化问题/</id>
    <published>2019-04-29T06:07:43.000Z</published>
    <updated>2019-04-29T06:12:13.808Z</updated>
    <content type="html"><![CDATA[<p>最近在做应用的jdk7升级8和核心类库升级的工作。发现一个把Double格式化成String的函数并不是每次都按照4舍5入进行格式化，例如1.325的运行结果是1.32，而12.345的运行结果则是12.35。这个问题是因为在二进制中并没有一个值能准确的表示这个十进制的小数值，只是非常接近这个十进制数值。</p>
<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/java-bug.png" alt=""></p>
<p>如果希望所见即所得的获取格式化结果，可以使用BigDecimal.toPlainString或者String.format代替DecimalFormat 进行浮点数格式化。<br>相同的情况也存在于new BigDecimal和BigDecimal.valueof中，使用new BigDecimal(double val)会得到更精准的值，但是BigDecimal.valueof才是所见即所得。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做应用的jdk7升级8和核心类库升级的工作。发现一个把Double格式化成String的函数并不是每次都按照4舍5入进行格式化，例如1.325的运行结果是1.32，而12.345的运行结果则是12.35。这个问题是因为在二进制中并没有一个值能准确的表示这个十进制的小数]]>
    </summary>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="jdk7" scheme="http://minotaursu.com/tags/jdk7/"/>
    
      <category term="jdk8" scheme="http://minotaursu.com/tags/jdk8/"/>
    
      <category term="开发" scheme="http://minotaursu.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈稳定性工作]]></title>
    <link href="http://minotaursu.com/2019/04/11/%E5%86%8D%E8%B0%88%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>http://minotaursu.com/2019/04/11/再谈稳定性/</id>
    <published>2019-04-11T08:33:17.000Z</published>
    <updated>2019-04-11T09:06:09.488Z</updated>
    <content type="html"><![CDATA[<p>之前也写过一篇稳定性工作的总结-<a href="http://minotaursu.com/2018/03/12/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/">如何保障高并发系统的稳定性与高可用</a>，但更多的是从系统开发者的角度说明如何保障单一系统的稳定性，做好自己负责系统的稳定性建设更多的是依赖知识和经验，是个技术活。负责了一整年的业务线稳定性建设之后，对于如何保障几十个系统的稳定性，协同几十人做好稳定性相关工作有了更多的思考和实践，又有了些新的体会，更需要科学的工程管理，涉及到多个方面。</p>
<h2 id="方向">方向</h2><ol>
<li>高可用<br>高可用要求系统有比较高的风险防范应对能力，把因软件/硬件/人为造成的故障对业务的影响降低到最小程度。系统能够对外提供有效服务的时间大于99.9%，99.99%，甚至是99.999%。 </li>
<li>零资损<br>高可用强调的是对外稳定服务，零资损强调的是内部资金安全。减少软件/硬件/人为的因素导致的资金损失风险。特别是计费，交易，营销这些和钱相关的系统。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/direction.png" alt=""></p>
<h2 id="维度">维度</h2><ol>
<li>流程规范<br>一个行之有效的流程对系统稳定性有着至关重要的作用。把流程规范的建立作为稳定性建设的开始是一个比较好的选择，不需要付出非常巨大的成本，但对稳定性的提升有着很大的帮助。好的流程规范应该覆盖项目整个生命周期（需求评审，项目管理，项目开发，code review，测试用例评审，上线流程，故障通报，故障复盘）尽可能的帮助开发避免风险点。</li>
<li>基础设施<br>基础设施建设是稳定性建设的核心方向。科技是第一生产力，工具可以带来能力和效率的大幅提升。只有具备完备而且强大的工具才有可能保障复杂系统的高可用，试想如果没有监控报警就连最基础的故障感知都无法做到，缺少运维工具的辅助想要做到故障的快速恢复更是天方夜谭。</li>
<li>稳定性意识<br>稳定性意识的提升是最基础也是最难的工作。很多人眼里只有业务功能，很少关心稳定性工作，需要在日常文化中强调稳定性的重要性，通过例会，巡检，定期演练的方式提升大家的稳定性意识。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/metrics.png" alt=""></p>
<h2 id="阶段">阶段</h2><ol>
<li>事前<br>事前重在风险的发现和预防，做好容量规划，服务治理，系统优化，慢查优化，提升系统鲁棒性。</li>
<li>事中<br>事中重在最快止损，最快定位。止损是第一优先级的事情，需要提前准备好故障预案。定位则依赖完备的工具和对系统业务的熟悉。</li>
<li>事后<br>事后重在修复故障影响，复盘和改进。一个故障的发生一定是要做到闭环的，必然存在可改进项，同时也要做到对事不对人。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/stage.png" alt=""></p>
<h2 id="架构">架构</h2><ol>
<li>网络层<br>网络层是系统架构中不确定性最高的部分。用户通过网络访问系统服务，网络的延迟和成功率直接影响着用户的体验，很可能由于运营商的设备升级和道路施工导致网络不可用，并且机房断电，火灾，地震..这些极端因素都会导致业务瘫痪，如果业务期望达到即使在此类灾难性故障的情况下，业务也不受影响，或者在几分钟内就能够很快恢复，那么就需要设计异地多活架构。根据地理位置上的距离来划分，异地多活架构可以分为同城异区、跨城异地、跨国异地。多活架构的最大难点就是地理位置导致的数据同步延迟和业务上强一致的矛盾。</li>
<li>应用层<br>应用层是系统架构中复杂度最高变化最频繁的部分。一个使用微服务架构的业务线涉及到几十个系统，几百个服务，几千个接口，系统间存在大量的交互，如何做好服务治理，保障应用层的稳定性是一个重大的挑战。</li>
<li>存储层<br>存储层是系统架构中最需要被保护的部分。存储层即强大又脆弱，缓存是系统高性能的核心，使系统能够承载高并发的流量带来的压力，同时缓存的穿透，雪崩也往往会导致大故障。mysql则是更加的脆弱，一个无索引的慢查，几个大事务都可能导致数据库的瘫痪。</li>
<li>中间件<br>中间件作为系统架构中的数据通道和流量通道，是稳定性发力的支点。可以通过在中间件中集成服务治理，限流，降级等策略使尽可能多的应用系统收益，中间件的一小步的优化往往会带来系统稳定性的一大步提升。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/layerx.png" alt=""></p>
<h2 id="架构原则">架构原则</h2><ol>
<li>冗余<br>冗余是高可用架构的核心原则。好的架构需要做到对流量冗余，资源冗余，硬件冗余，也是异地多活，集群部署，容量规划的核心思想。</li>
<li>隔离<br>隔离是高可用架构的另一个核心原则。除了冗余之外也需要做好故障隔离，资源隔离，前后台隔离，在线离线隔离，防止故障在线程，进程，应用，领域之间的传播，小的风险演变成大的事故。</li>
</ol>
<h2 id="全局工作概览">全局工作概览</h2><p>最后是一张全局工作概览图，有些已经做的比较成熟，有些还需要继续完善。</p>
<p><img src="https://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/availability.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前也写过一篇稳定性工作的总结-<a href="http://minotaursu.com/2018/03/12/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%]]>
    </summary>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="稳定性" scheme="http://minotaursu.com/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
      <category term="高可用" scheme="http://minotaursu.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="高并发" scheme="http://minotaursu.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的类库选择]]></title>
    <link href="http://minotaursu.com/2019/02/18/%E6%88%91%E7%9A%84%E7%B1%BB%E5%BA%93%E9%80%89%E6%8B%A9/"/>
    <id>http://minotaursu.com/2019/02/18/我的类库选择/</id>
    <published>2019-02-18T08:14:43.000Z</published>
    <updated>2019-02-18T08:18:19.672Z</updated>
    <content type="html"><![CDATA[<p>好的类库可以提升简化代码，提高开发效率，这里列出一些我常用的类库。</p>
<ol>
<li>json相关<br>fastjson，jackson。fastjson偏重的是简单和快速，内部实现有很多的hack。而jackson偏重的是标准和强大。国内项目使用fastjson会多一些。</li>
<li>date相关<br>joda-time。</li>
<li>io相关<br>guava。</li>
<li>集合相关<br>guava。</li>
<li>数学计算<br>guava。</li>
<li>内存缓存。<br>guava。</li>
<li>xml相关<br>xstream。</li>
<li>html相关<br>jsoup。</li>
<li>bean mapper<br>dozer，cglib。dozer最灵活，性能比较差，cglib的beancopier基于ASM字节码实现，性能接近getter/setter方法，少量对象mapper建议使用dozer。</li>
<li>字节码<br>Javassist，asm。Javassist的使用更加方便。</li>
<li>模版引擎<br>freemaker，velocity。freemaker功能更强大，velocity 简单，性能好，内部模版渲染建议使用freemaker，大量页面生成使用velocity。</li>
<li>http相关<br>okhttp</li>
<li>日志相关<br>slf4j</li>
<li>网络相关<br>netty</li>
<li>测试相关<br>junit，mockito。写单元测试的开发才是负责的RD</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>好的类库可以提升简化代码，提高开发效率，这里列出一些我常用的类库。</p>
<ol>
<li>json相关<br>fastjson，jackson。fastjson偏重的是简单和快速，内部实现有很多的hack。而jackson偏重的是标准和强大。国内项目使用fastjson]]>
    </summary>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="开发" scheme="http://minotaursu.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何保障高并发系统的稳定性与高可用]]></title>
    <link href="http://minotaursu.com/2018/03/12/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://minotaursu.com/2018/03/12/如何保障高并发系统的稳定性与高可用/</id>
    <published>2018-03-12T10:49:33.000Z</published>
    <updated>2019-02-01T09:02:25.352Z</updated>
    <content type="html"><![CDATA[<p>要论如何搞垮一家互联网公司，速度最快的不是产品经理的胡乱决策，运营的无休止的烧钱，客服人员对客户的冷漠，一定是系统核心功能持续的不可用，一次大规模的故障可能造成几千万的损失，市值大量蒸发，PR风险，甚至工信部的约谈。<br><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/kdn.png" alt=""></p>
<p>一般的系统对全年可用性要求是99%或者99.9%，而影响着千万人日常生活的系统一般都要求全年系统可用性在4个9以上，这可不是一个容易达到的目标，那么如何避免故障，保障系统的稳定性与高可用，根据总结别人的方法和自身的经验，想要做好稳定性与高可用有16字心决</p>
<blockquote>
<p>完善基础，做好自身，容错下游，防备上游</p>
</blockquote>
<p>说起来影响稳定性的因素无非内部变化与外部变化，应对的心决也只有短短的16个字，然而魔鬼就在细节中，稳定性与高可用的建设中需要完善的基础设施支持，高效的制度规范，无数程序员的付出，上千万真金白银的投入。</p>
<h1 id="完善基础">完善基础</h1><p>所谓工欲善其事，必先利其器。完善的基础设施建设是一切的开始，对于稳定性建设不可或缺的三个基础设施就是监控，压测，降级。</p>
<h3 id="监控系统">监控系统</h3><p>监控能够量化系统的运行情况，是问题发现和系统优化的基础，没有监控就不能知道系统发生了什么问题，不能知道系统运行指标也就是无法做出针对性的优化。完善的监控需要将系统，应用，数据库，缓存，核心组件，第三方依赖纳入进来，做到面面俱到，并且能够第一时间就看到系统的核心指标，还需要对重要的应用指标，业务指标，投诉指标都设置好报警规则。分布式追踪系统也是发现问题的重要手段，需要核心功能链路上的服务都进行接入。</p>
<h3 id="压测">压测</h3><p>如果说监控系统是系统的体检报告，那么压测就是体能测试。监控系统可以看到过去和当前的指标，压测则是对未来的预测。一般来说压测分为单机压测和系统的压测，单机压测比较合适压测某个特定的场景和项目，好处是压测实施简单，可以压测出一个系统极限值，缺点是和系统的真实运行情况有一定差距。系统间压测的最好形式就是全链路压测，全链路压测更接近系统的真实运行情况，可以找出应用，存储，缓存，依赖服务，网络情况的瓶颈。</p>
<h3 id="降级">降级</h3><p>优雅降级是应对突发情况的重要手段，当系统发生故障时如何快速止损就是第一优先级的事情，如果没有相应的措施只能眼睁睁看着系统的故障发展，甚至造成多米诺骨牌效应。主要的降级方式有限流和熔断，可降级点有核心功能的非核心依赖，非核心服务，高并发接口，高资源消耗服务，对于高并发应用日志级别的动调调整也是重要的一个功能点。关于降级最重要的事情就是要日常演练一定要测试正确性，一定要测试正确性，一定要测试正确性，没有被验证正确的降级反而可能引起更严重的事故。</p>
<h1 id="做好自身">做好自身</h1><h3 id="控制资源合理使用">控制资源合理使用</h3><p>做系统设计，代码实现时一定要意识到所有的资源都是有限的，cpu，内存，磁盘，网络，线程，一旦某个资源超过负载，很容易出现线上问题。</p>
<h4 id="cpu">cpu</h4><p>良好的系统CPU的高峰期空闲率应该在40%以上，线程，锁，gc，代码循环这些因素都会影响CPU的负载，一般来说要重点预防的是死锁的情况（例如多线程情况下hashmap死锁），一旦死锁会出现CUP使用率骤增导致系统故障。</p>
<h4 id="内存">内存</h4><p>内存的使用最重要的是避免OOM和内存泄露，一旦发生很可能就是线上事故。其次的重点是大数据量下不要使用内存缓存(guava，ehcache)，频繁的GC会造成系统的可用性大幅降低，堆外内存的使用也需要重点关注，合适的数据压缩算法可以提供内存的利用率。</p>
<h4 id="磁盘">磁盘</h4><p>日志打印要精简，需要定期对日志进行归档清理，并且要对磁盘的使用量设置监控，建议接入动态调整日志级别功能在发生问题时可以进行日志降级，对于高并发的系统建议异步输出日志。</p>
<h4 id="线程池">线程池</h4><p>根据多年的经验线程池是最容易出问题的点之一，使用线程池一定要设置队列大小并且对于要求快速响应的系统来说队列长度设置过大也没有意义。线程池的core size和max size一定要合理设置，至少需要冗余高峰期3倍以上的流量，如果下游系统响应变慢/超时导致线程池打满，而线程池服务于核心功能的代码时非常容易出现故障。能否合理的设置线程池是判定程序员是否有资源有限，容错设计意识的重要标准。</p>
<h3 id="mysql">mysql</h3><p>和其他无状态的业务服务不同，数据库作为有状态服务很难通过加机器解决容量问题，考虑到业务的发展，流量爆发的突然性，业界有着系统架构支持10倍增长，系统设计支持5倍增长，系统实现支持2倍增长的说法，最好在设计时就做好垂直拆分，水平拆分的工作，单个数据库的IO，网络，磁盘，CPU都有限制。另外一件重要的事情就是一定要建立合适的索引，避免慢查询，而过多的索引也会影响写性能。</p>
<h3 id="避免单点">避免单点</h3><p>一定不要把鸡蛋都放在一个篮子里，不要求大的架构层面的异地多活，单元化，最基本要部署多个节点，通过负载均衡访问。</p>
<h1 id="容错下游">容错下游</h1><p>被下游服务拖垮是1024种线上事故中非常经典的一种，显然我们不希望因为下游服务挂了自己的业务也跟着挂掉。为了保护自己的业务需要做以下几件事情。</p>
<h3 id="有兜底，有熔断">有兜底，有熔断</h3><p>对于外部依赖，一定要做到兜底和熔断，通过检测超时情况或者异常情况，当依赖服务不可用时可以使用本地的兜底策略，向上提供有损服务，保证业务柔性可用。</p>
<h3 id="一定要设置超时时间">一定要设置超时时间</h3><p>假设某服务的响应时间是50ms，线程池是200，假设系统没有超时时间设置，响应时间从50ms突变到5000ms，瞬间就能打满线程池导致服务不可用。为了保证系统不被下游的变慢拖垮一定要设置超时时间，建议内部接口都设置在200ms以下，依赖第三方公网服务的接口设置在1500ms以下。</p>
<h3 id="谨慎设置重试次数">谨慎设置重试次数</h3><p>合理的设置重试次数即是保护下游也是保护自己，假设重试次数过多会导致服务响应时间的变慢（超时时间*重试次数），并且很容易引起下游的雪崩，导致下游长时间不可用。建议重要的接口设置2次重试，不必要的接口都不要设置重试次数。</p>
<h1 id="防备上游">防备上游</h1><p>被上游陡增的流量打垮是1024种线上事故中非常经典的另一种，这里区分2种情况来讨论，一种是活动流量，需要预测活动预期的流量峰值，对高资源消耗的非核心功能提前降级，做好压测和降级预案，并设置一定的用户流控。另一种是内部的猪队友作案，可能顺手写个循环就带来10倍的流量增长，这种情况也要设置好系统的流量阀值，并且需要做到流量的按需分配，能够弄清楚流量的来源。<br>最后自己画了一张图，对可能的情况和故障做一个总结。</p>
<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/robust.png" alt=""></p>
<p>通过上文可以发现监控(量化过去和现在)，压测（预测未来），降级（预防故障，快速止损）对系统的重要性。其中容错下游（熔断）和防备上游（限流）同样需要依靠降级服务实现，提到降级服务我们会想到Hystrix，除此之外滴滴出行有经验的老司机都会选择SDS（service downgrade system），SDS是一个由多位资深工程师开发的纯java语言降级系统，支持访问量，并发量，异常量，超时时间等多个监控指标的降级点，支持滑动窗口，令牌桶等多种算法，在数据可视化方面支持多种数据源（mysql，mongo，elasticsearch，influxdb）的存储和展示，可以选择喜欢的数据源进行降级可视化配置。相信在不久的未来就会开源和大家见面。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>要论如何搞垮一家互联网公司，速度最快的不是产品经理的胡乱决策，运营的无休止的烧钱，客服人员对客户的冷漠，一定是系统核心功能持续的不可用，一次大规模的故障可能造成几千万的损失，市值大量蒸发，PR风险，甚至工信部的约谈。<br><img src="http://raw.gith]]>
    </summary>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="稳定性" scheme="http://minotaursu.com/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
      <category term="高可用" scheme="http://minotaursu.com/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="高并发" scheme="http://minotaursu.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[所有需要知道的GC知识]]></title>
    <link href="http://minotaursu.com/2018/03/03/%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84GC%E7%9F%A5%E8%AF%86/"/>
    <id>http://minotaursu.com/2018/03/03/所有需要知道的GC知识/</id>
    <published>2018-03-02T16:24:51.000Z</published>
    <updated>2019-02-01T09:02:25.338Z</updated>
    <content type="html"><![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jvmspeed.png" alt=""><br>作为一个java语言开发的应用，为了每一个0.1%的性能提升，折腾过了网络，IO，数据库之后难免要折腾一下GC。写下这篇日志的目的是希望看完这篇日志后，关于GC的问题能从google+stackoverflow寻找答案的过程中解脱出来，99%的GC问题都能独立解决，也方便自己温故知新。日志将从JVM内存结构 - 垃圾回收器 - 一些JVM参数 - 看懂GC日志 - 实际案例 - 建议配置 这几个方面详细介绍GC。在写这篇日志的过程中发现越写越长，需要详细介绍和深究原理的内容越来越多，不由得感慨网上的blog只能传递某几个知识点，想要构建一个完整的知识网络还是需要深入阅读相关的书籍，唯有将知识网络构建的越来越严密才能应对遇到的各种问题。</p>
<h1 id="JVM内存结构">JVM内存结构</h1><p>目前主流的JVM都将内存分成不同的区域，JVM内存结构主要由堆，方法区和栈组成，堆作为最大一块的内存又由Eden空间、From Survivor空间、To Survivor空间，Old空间组成。<br><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jvm.png" alt=""><br>新生代（Young Generation）：大多数对象在新生代中被创建(某些大对象可能直接创建在老年代)，其中很多对象的生命周期很短。<br>一般而言新生代内又分三个区：一个Eden区，两个Survivor区，当Eden区满时，还存活的对象将被复制到其中一个Survivor区。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。<br>老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC。</p>
<h1 id="垃圾回收器">垃圾回收器</h1><h3 id="串行（Serial）回收器">串行（Serial）回收器</h3><p>串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。在串行收集器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成，这样给用户体验造成较差效果。虽然如此，串行收集器却是一个成熟、经过长时间生产环境考验的极为高效的收集器。新生代串行处理器使用复制算法，实现相对简单，逻辑处理特别高效，且没有线程切换的开销。在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，它的性能表现可以超过并行回收器和并发回收器。在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。</p>
<h3 id="并行（ParNew）回收器">并行（ParNew）回收器</h3><p>并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。并行回收器也是独占式的回收器，在收集过程中，应用程序会全部暂停。但由于并行回收器使用多线程进行垃圾回收，因此，在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器，而在单 CPU 或者并发能力较弱的系统中，并行回收器的效果不会比串行回收器好，由于多线程的压力，它的实际表现很可能比串行回收器差。<br>开启并行回收器可以使用参数-XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代使用串行收集器。</p>
<h3 id="吞吐量优先（Parallel_Scavenge）回收器">吞吐量优先（Parallel Scavenge）回收器</h3><p>吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。从表面上看，它和并行收集器一样都是多线程、使用复制算法的并行收集器。但是，并行Parallel Scavenge集器有一个重要的特点：它非常关注系统的吞吐量。使用-XX:+UseParallelOldGC 可以在新生代和老生代都使用并行回收收集器，这是一对非常关注吞吐量的垃圾收集器组合，在对吞吐量敏感的系统中，可以考虑使用。参数-XX:ParallelGCThreads也可以用于设置垃圾回收时的线程数量。另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用。</p>
<h3 id="并发标记清除（CMS，Concurrent_Mark_Sweep）回收器">并发标记清除（CMS，Concurrent Mark Sweep）回收器</h3><p>并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。与并行回收收集器不同，CMS 收集器主要关注于系统停顿时间。CMS 是 Concurrent Mark Sweep 的缩写，意为并发标记清除，从名称上可以得知，它使用的是标记-清除算法，同时它又是一个使用多线程并发回收的垃圾收集器。<br>CMS 工作时，主要步骤有：初始标记、并发标记、并发预清理、重新标记、并发清除和重置。其中初始标记和重新标记是独占系统资源的，而并发标记、并发清除和并发重置是可以和用户线程一起执行的。因此，从整体上来说，CMS 收集不是独占式的，它可以在应用程序运行过程中进行垃圾回收。</p>
<h3 id="G1回收器_(Garbage_First)">G1回收器 (Garbage First)</h3><p>G1收集器是当今收集器技术发展最前沿的成果之一，目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。与 CMS 收集器相比，G1收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制，这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒。使用参数-XX:+UnlockExperimentalVMOptions –XX:+UseG1GC 来启用 G1 回收器，设置 G1 回收器的目标停顿时间：-XX:MaxGCPauseMills=20,-XX:GCPauseIntervalMills=200。</p>
<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/garbage.png" alt=""></p>
<h1 id="一些参数">一些参数</h1><p>-Xms 设置堆的最小空间大小。<br>-Xmx 设置堆的最大空间大小。<br>-Xmn 设置新生代最小空间大小（推荐使用）。<br>-XX:NewSize 设置新生代最小空间大小。<br>-XX:MaxNewSize 设置新生代最大空间大小。<br>-XX:SurvivorRatio 设置Eden:Survivor中的一个比例,默认是8:1:1<br>-XX:PermSize 设置永久代最小空间大小。<br>-XX:MaxPermSize 设置永久代最大空间大小。<br>-Xss 设置每个线程的堆栈大小<br>老年代空间大小=堆空间大小-年轻代大空间大小<br>-XX:+DisableExplicitGC 显示禁止System.gc()，System.gc()变成一行无效的代码，如果系统有使用堆外内存不建议配置这个jvm参数<br>-XX:+UseConcMarkSweepGC 设置老年代为并发收集<br>-XX:+CMSParallelRemarkEnabled 降低标记停顿<br>-XX:+UseCMSCompactAtFullCollection 打开对年老代的压缩。可能会影响性能，但是可以消除碎片<br>-XX:LargePageSizeInBytes 设置内存页的大小<br>-XX+UseCMSInitiatingOccupancyOnly 标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期，始终使用CMSInitiatingPermOccupancyFraction的值（不推荐使用）<br>-XX:CMSInitiatingOccupancyFraction，默认为68，即当年老代的空间使用率达到68%时，会执行一次CMS回收。如果应用程序的内存使用率增长很快，在CMS的执行过程中，已经出现了内存不足，此时，CMS回收就会失败，虚拟机将启动SerialOld串行收集器进行垃圾回收。如果这样，应用程序将完全中断，直到垃圾回收完成，这时，应用程序的停顿时间可能会较长<br>-XX:+CMSScavengeBeforeRemark 强制重新标记前进行一次MinorGC，如果Eden区有大量活跃对象推荐使用。<br>-XX:+PrintGCDetails 输出GC的详细日志<br>-XX:+PrintGCTimeStamps 输出GC的时间戳<br>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>-XX:+PrintTenuringDistribution 指定JVM在每次新生代GC时，输出幸存区中对象的年龄分布</p>
<h1 id="看懂GC日志">看懂GC日志</h1><h3 id="一次典型的minorGC日志示例:">一次典型的minorGC日志示例:</h3><p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/gcprocess.png" alt=""></p>
<h3 id="一次典型的CMS_GC日志示例:">一次典型的CMS GC日志示例:</h3><p>39.910: [GC 39.910: [ParNew: 261760K-&gt;0K(261952K), 0.2314667 secs] 262017K-&gt;26386K(1048384K), 0.2318679 secs]<br>新生代使用 (ParNew 并行)回收器。新生代容量为261952K，GC回收后占用从261760K降到0,耗时0.2314667秒。(译注：262017K-&gt;26386K(1048384K), 0.2318679 secs 表示整个堆占用从262017K 降至26386K,费时0.2318679)</p>
<p>40.146: [GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K), 0.0074495 secs]<br>开始使用CMS回收器进行老年代回收。初始标记(CMS-initial-mark)阶段,这个阶段标记由根可以直接到达的对象，标记期间整个应用线程会暂停。<br>老年代容量为786432K,CMS 回收器在空间占用达到 26386K 时被触发</p>
<p>40.154: [CMS-concurrent-mark-start]<br>开始并发标记(concurrent-mark-start) 阶段，在第一个阶段被暂停的线程重新开始运行，由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。</p>
<p>40.683: [CMS-concurrent-mark: 0.521/0.529 secs]<br>并发标记阶段结束，占用 0.521秒CPU时间, 0.529秒墙钟时间(也包含线程让出CPU给其他线程执行的时间)</p>
<p>40.683: [CMS-concurrent-preclean-start]<br>开始预清理阶段<br>预清理也是一个并发执行的阶段。在本阶段，会查找前一阶段执行过程中,从新生代晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。</p>
<p>40.701: [CMS-concurrent-preclean: 0.017/0.018 secs]<br>预清理阶段费时 0.017秒CPU时间，0.018秒墙钟时间。</p>
<p>40.704: [GC40.704: [Rescan (parallel) , 0.1790103 secs]40.883: [weak refs processing, 0.0100966 secs] [1 CMS-remark: 26386K(786432K)] 52644K(1048384K), 0.1897792 secs]<br>Stop-the-world 阶段,从根及被其引用对象开始，重新扫描 CMS 堆中残留的更新过的对象。这里重新扫描费时0.1790103秒，处理弱引用对象费时0.0100966秒，本阶段费时0.1897792 秒。</p>
<p>40.894: [CMS-concurrent-sweep-start]<br>开始并发清理阶段，在清理阶段，应用线程还在运行。</p>
<p>41.020: [CMS-concurrent-sweep: 0.126/0.126 secs]<br>并发清理阶段费时0.126秒</p>
<p>41.020: [CMS-concurrent-reset-start]<br>开始并发重置</p>
<p>41.147: [CMS-concurrent-reset: 0.127/0.127 secs]<br>在本阶段，重新初始化CMS内部数据结构，以备下一轮 GC 使用。本阶段费时0.127秒</p>
<h1 id="一些case">一些case</h1><h3 id="频繁MinorGC和MajorGC">频繁MinorGC和MajorGC</h3><p>某应用配置xms=6g xmx=6g xmn=4g，高峰期应用每10s发生一次Minor GC，每次GC时间在10-20ms，每40min发生一次Major GC，每次GC时间在100ms-200ms。配置成xms=10g xmx=10g xmn=7g后，高峰期应用每30s发生一次Minor GC，每次GC时间在20-30ms，每天发生一次Major GC，每次GC时间在100ms-200ms。 通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率,单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区),扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。</p>
<h3 id="偶发长时间FULLGC">偶发长时间FULLGC</h3><p>某应用正常FULLGC时间是100-200ms，会偶发耗时大于1000ms的FULLGC，分析GC日志发现耗时突增主要发生在remark阶段， Remark耗时&gt;1000ms时，新生代使用率都在75%以上。新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。使用这个配置之后FULLGC的时间再也没有超过1000ms。</p>
<h3 id="必现长时间FULLGC">必现长时间FULLGC</h3><p>某应用每周发生一次FULLGC，正常时间都在500ms以下，突然在某个时间点之后发生的FULLGC耗时都超过了5000ms，耗时增加了一个数量级。分析发现GC真实的耗时是远大于用户耗时和系统耗时的，例如:[Times: user=2.56 sys=0.07, real=9.82 secs]。有些时候系统活动诸如内存换入换出（vmstat）、网络活动（netstat）、I/O （iostat）在 GC 过程中发生会使 GC 时间变长。特别是有 SWAP 区域（用 top、 vmstat 等命令可以看出）用于内存的换入换出，那么操作系统可能会将 JVM 中不活跃的内存页换到 SWAP 区域用以释放内存给线程使用（这也透露出内存开始不够用了）。内存换入换出是一个开销巨大的磁盘操作，比内存访问慢好几个数量级。在减小JVM大小，禁用swap后应用恢复正常。</p>
<h3 id="大量使用枚举导致频繁GC">大量使用枚举导致频繁GC</h3><p>某任务类应用配置xms=6g xmx=6g xmn=4g，解析文件生成对象进行处理，大量发生MinorGC和FULLGC，调整jvm参数后改善有限，执行jmap -histo:live [pid] 后发现大量枚举对象，应用中大量使用枚举以及valueOf方法生成枚举。使用静态map替换枚举的valueof方法后FULLGC的频率降低到原来的1/10。</p>
<h1 id="建议配置">建议配置</h1><p>首先确定一下我们的目标，降低GC对性能的影响，最小化STW的时间，每次STW的时间都小于服务最大响应时间的要求。更具体的目标就是最小化fullGC的频率及持续时间，最小化minorGC频率及持续时间。为了实现这个目标有以下几点限制：</p>
<ol>
<li>堆大小在合理的范围</li>
<li>老年代大小在合理的范围</li>
<li>幸存区大小在合理的范围</li>
</ol>
<p>堆大小直接影响到GC的频率和时间，业务场景，应用和硬件都会对堆大小的设置产生影响，要想获得一个合适的大小，只能通过不断的测试调优。个人经验是响应时间优先的应用为操作系统和日志采集预留出足够的内存并且不大于16G的范围内堆设置的越大越好(如果业务量比较小可能造成浪费)。<br>老年代的大小直接影响FULLGC的频率和时间，个人经验是设置成高峰期老年代活跃数据的大小的3倍。<br>幸存区大小会影响晋升到老年代对象的数量，minorGC的持续时间。个人经验是幸存区的大小需要能够容纳存活的对象到达配置的MaxTenuringThreshold年龄，避免promotion failed。</p>
<p>参考:<br><a href="https://tech.meituan.com/jvm_optimize.html" target="_blank" rel="external">从实际案例聊聊Java应用的GC优化</a><br><a href="http://www.importnew.com/22886.html" target="_blank" rel="external">JVM 调优 —— GC 长时间停顿问题及解决方法</a><br><a href="https://www.jianshu.com/p/051d566e110d" target="_blank" rel="external">海量连接服务端jvm参数调优杂记</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jvmspeed.png" alt=""><br>作为一个java语言开发的应用，为了每一个0.]]>
    </summary>
    
      <category term="gc" scheme="http://minotaursu.com/tags/gc/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <link href="http://minotaursu.com/2018/02/22/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://minotaursu.com/2018/02/22/2017年终总结/</id>
    <published>2018-02-22T06:17:55.000Z</published>
    <updated>2019-02-01T09:02:25.324Z</updated>
    <content type="html"><![CDATA[<p>作为工作第N年的第M份总结还是要感叹一下时间的飞快, 首先总结一下认为比较重要的几件事情。</p>
<ol>
<li>去日本关西玩了一趟，也算是第一次去发达国家了，住的民宿，性价比特别高，日本的交通不是一般的贵。作为消费者喜欢日本的精致服务，但并不想在日本生活。。</li>
<li>去了南京看中山陵，沧桑国府，金陵一梦。</li>
<li>老婆去了阿里，工资涨了不少，工作也忙了很多，如果自己还在阿里不离职不晋升可能还没老婆工资高。。</li>
<li>在滴滴经历了一次晋升，全票通过，精神上得到了认同。</li>
<li>买了车，还清了除房贷车贷之外的一切贷款，财富从消费阶段转向积累阶段。</li>
<li>工作上做了很多业务开发之外的工作，学到了不少东西。</li>
<li>王者农药单排段位达到王者，坚持你所坚持，很多事情比想象的简单。</li>
<li>星际二战役全通。</li>
<li>2017年的wishlist完成了60%,希望2018年的wishlist能完成80%以上。</li>
</ol>
<p>2017年是工作和生活平衡的一年，前半年更加生活，和老婆一起吃了很多晚饭，周边游国外游都有，也和小伙伴们一起5排过。下半年系统的压力很大，项目也多，工作上尝试了很多方法，做了不少事情，加了不少班，也得到了认可。整体而言工作中生活中都在忙，缺少了悟，2018年还是希望多读一些书(30本以上)，多一些感悟和参悟，对未来有一定的预见。</p>
<p>2018·wishlist</p>
<ol>
<li>云南/亚洲某国行一次，目的地视财力而定</li>
<li>为知名开源项目贡献一次代码，例如elasticsearch，netty等</li>
<li>完成 <a href="http://book.douban.com/people/49806902/wish" target="_blank" rel="external">豆瓣阅读列表</a></li>
<li>做事更有条理，寻找更多的可能性</li>
<li>学会吉他</li>
<li>2018年总结时，列出一件自己觉得NB的事情</li>
</ol>
<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/hzdream.png" alt="人的梦想，是不会终结的"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为工作第N年的第M份总结还是要感叹一下时间的飞快, 首先总结一下认为比较重要的几件事情。</p>
<ol>
<li>去日本关西玩了一趟，也算是第一次去发达国家了，住的民宿，性价比特别高，日本的交通不是一般的贵。作为消费者喜欢日本的精致服务，但并不想在日本生活。。</li>]]>
    </summary>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="总结" scheme="http://minotaursu.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="滴滴" scheme="http://minotaursu.com/tags/%E6%BB%B4%E6%BB%B4/"/>
    
      <category term="阿里" scheme="http://minotaursu.com/tags/%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次GC耗时超长的问题排查]]></title>
    <link href="http://minotaursu.com/2018/02/22/%E4%B8%80%E6%AC%A1GC%E8%80%97%E6%97%B6%E8%B6%85%E9%95%BF%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://minotaursu.com/2018/02/22/一次GC耗时超长的问题排查/</id>
    <published>2018-02-22T03:57:06.000Z</published>
    <updated>2019-02-01T09:02:25.335Z</updated>
    <content type="html"><![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/gc.png" alt=""></p>
<p>2017年10月某日突然收到FullGC耗时超长的报警，排查发现应用存在周期性FULLGC耗时超长的的情况，每次FULLGC时间长达5s以上，甚至出现过10s以上的FULLGC，导致FULLGC时应用的响应全部超时。最初是怀疑系统有大量的对象没有释放导致FULLGC时间过长，第一时间dump了应用的内存，并没有发现内存泄露的情况。后面查看GC日志发现Rescan阶段weak refs processing的超时都超长，GC日志里大量可见[weak refs processing, 9.7398650 secs]，排查的方向就逐渐转向了weak refs processing 为什么会花费如此长的时间，大家在一起针对代码分析了很久，从jackson的使用，到本地缓存的使用，到NIO的影响，每个人都提出了自己的见解，但是又没有强有力的证据验证自己的结果，按照这个思路排查了一晚上也没有结果。<br>后面分析发现耗时超长的FULLGC只出现在特定的某一台服务器上，该应用的FULLGC耗时在其他服务器上都表现正常，排查发现出现GC耗时过长的服务器还部署着大数据的某个高IO类型的应用，排查的思路又转向了服务器的IO和cpu，但是并没有发现io和cpu的异常情况，排查似乎陷入了困境。<br><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/easygc.png" alt=""><br>过了几天之后找到了一个可视化的GC分析工具<a href="http://gceasy.io/" target="_blank" rel="external">gceasy.io</a> ，分析后发现一个之前一直忽略的现象，GC真实的耗时是远大于用户耗时和系统耗时的，[Times: user=2.56 sys=0.07, real=9.82 secs]。我们知道JVM本身作为一个进程也是由linux系统进行内存分配，而linux的内存空间由两部分构成，物理内存和swap空间，假如GC时有一部分内容被交换到swap，遍历到这部分的时候就需要将其交换回内存，极端情况下甚至会把整个堆分区轮流往SWAP写一遍，而磁盘交换的速度是远慢于物理内存的，如果GC和swap同时发生会导致超长时间的卡顿，通过sar -W -f 命令分析发现swap时间完全吻合发生耗时超长的GC时间，基本可以断定是系统的物理内存不够用导致系统发生swap，最终导致耗时超长的GC发生，关闭linux的swap后引用的GC时间恢复到500ms以下。<br>虽然gc耗时超长的问题得到了解决，但是仔细思考一下就会发现问题的解决完全依赖程序员的推理过程和知识储备，那么是不是可以有更简单更快速的问题排查定位手段，我认为答案是可以的，那就是更加智能化的监控，将业务指标，应用指标，系统指标打通关联，在FULLGC超时报警的时候通知告知业务开发系统发生了swap，并且能展示对订单量和GMV等指标的影响。好的基础设施就像强大的武器，虽然依赖好的枪法用手枪也能杀死敌人，但是手里有把AKM或M16还是更容易吃鸡。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/gc.png" alt=""></p>
<p>2017年10月某日突然收到FullGC耗时超长的]]>
    </summary>
    
      <category term="gc" scheme="http://minotaursu.com/tags/gc/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="性能" scheme="http://minotaursu.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jackson使用setDateFormat后反序列化错误]]></title>
    <link href="http://minotaursu.com/2017/12/22/jackson%E4%BD%BF%E7%94%A8setDateFormat%E5%90%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%94%99%E8%AF%AF/"/>
    <id>http://minotaursu.com/2017/12/22/jackson使用setDateFormat后反序列化错误/</id>
    <published>2017-12-22T04:08:57.000Z</published>
    <updated>2019-02-01T09:02:25.329Z</updated>
    <content type="html"><![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jackson.png" alt=""></p>
<p>最近marketing-activity系统在接入降级服务，出现启动时可以正确获取到降级配置，系统运行一段时间后修改降级策略不生效的问题，之前订单系统，用户系统和其他系统的接入都没问题出现这个问题，肯定是触发了某种特定的case。营销的同学联系我进行排查，排查日志发现是降级服务反序列化Date类型异常，接收到的数据格式是yyyy-MM-dd HH:mm:ss，并不在jackson支持的反序列化格式之内。降级服务的sdk也是使用的jackson进行序列化的，为什么会出现jackson序列化后的数据却不能使用jackson反序列化。<br>接着查看marketing-activity系统的降级服务sdk日志发现一个很诡异的现象，最初发送的序列化后的请求还是时间戳格式的，运行一段时间后就变成了yyyy-MM-dd HH:mm:ss格式，也就是说系统的行为在运行时被改变了。<br><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/sds-log.png" alt=""></p>
<p>那么到底是什么可以改变系统运行时的序列化逻辑呢？可能出现的主要原因有2种。一种是字节码技术，也就是btrace，greys这些。另一种就是调用jackson本身的api改变了一些属性。显然第二种的可能性更大一些，果然在jsonUitl里发现了蛛丝马迹，toObject允许设置特定的时间格式进行反序列化，调用setDateFormat会导致后续全部的Date类型的序列化都会是yyyy-MM-dd HH:mm:ss格式，自然不能默认设置的jackson反序列化。<br><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jsonutil.png" alt=""></p>
<p>至此降级服务改变策略后不生效的根本原因就得到了解答，那么如果某个对象就是要使用yyyy-MM-dd HH:mm:ss 进行序列化和反序列化怎么办，建议使用@JsonFormat 单独对属性进行注释。<br>最后谈谈fastjson和jackson，貌似jackson的各种坑遇到过很多，而fastjson的坑很少，那么为什么jackson还是要比fastjson更流行，真的只是国外的月亮更圆，空气更甜？这个主要是json框架的设计理念偏重点不同，fastjson偏重的是简单和快速，内部实现有很多的hack和magic code。而jackson偏重的是标准和强大，格式支持json，xml，有很多的属性可以设置非常的灵活，也有很多的接口可以自定义进行扩展，导致学习成本比较高，需要详细看过jackson文档才能上手。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/jackson.png" alt=""></p>
<p>最近marketing-activity]]>
    </summary>
    
      <category term="jackson" scheme="http://minotaursu.com/tags/jackson/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="json" scheme="http://minotaursu.com/tags/json/"/>
    
      <category term="工作" scheme="http://minotaursu.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[更换一门工作语言的成本]]></title>
    <link href="http://minotaursu.com/2017/12/18/%E6%9B%B4%E6%8D%A2%E4%B8%80%E9%97%A8%E5%B7%A5%E4%BD%9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%88%90%E6%9C%AC/"/>
    <id>http://minotaursu.com/2017/12/18/更换一门工作语言的成本/</id>
    <published>2017-12-18T08:21:21.000Z</published>
    <updated>2019-02-01T09:02:25.349Z</updated>
    <content type="html"><![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/lang.jpg" alt=""></p>
<p>程序员这个职业经常需要学习新的技术，假如某一天工作上主要使用的语言没落了，或者新的项目需要使用另一门不熟悉的语言开发，那么成本到底有多少，那些是需要重新学习的，又有那些是可以被保留或者继承的。</p>
<h3 id="需要重新学习的">需要重新学习的</h3><ol>
<li>语法&amp;语法糖。这应该是最简单的部分，是用大括号分组还是使用缩进分组，条件语句是否需要括号，函数是否可以赋值给变量，是否支持lambda。</li>
<li>语言中的对象&amp;集合。可以看做是更高一级的语法，用来处理数据结构。</li>
<li>怎么处理io&amp;网络&amp;数据库连接。 上点规模的项目必然用到。</li>
<li>经典的第三方库。需要一段时间。</li>
<li>经典的应用框架。使用可能比较快，解决疑难bug和二次开发需要对源码有一定了解。</li>
<li>线程协程。想要写出高效的代码必须精通。</li>
<li>语言相关的中间件。这可能是成本最高，最痛苦的部分。</li>
</ol>
<h3 id="不需要重新学习的">不需要重新学习的</h3><ol>
<li>如何学习一门语言。不开玩笑，这才是最重要的技能，熟悉一门语言后学习新的语言会快很多。</li>
<li>数据结构和算法的知识。</li>
<li>操作系统。</li>
<li>io&amp;网络&amp;数据库方面的知识。</li>
<li>数据库调优。</li>
<li>业务系统设计。</li>
<li>架构思想。MVC分层，微服务。</li>
<li>中间件的原理。</li>
<li>业务知识。</li>
<li>思维逻辑。</li>
</ol>
<p>需要重新学习的主要集中在工具层面，保留的主要是思想和原理。看起来重新学习一门语言就像一个内力深厚的高手不再用剑改学刀法，问题不会很大，但也不是毫无风险，初学期遇到一个难缠的对手也容易乱拳打死老师傅。可能需要一个月到半年的熟悉期。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://raw.githubusercontent.com/minotaursu/minotaursu.github.io/source/images/lang.jpg" alt=""></p>
<p>程序员这个职业经常需要学习新的技术，假如某一天]]>
    </summary>
    
      <category term="go" scheme="http://minotaursu.com/tags/go/"/>
    
      <category term="java" scheme="http://minotaursu.com/tags/java/"/>
    
      <category term="python" scheme="http://minotaursu.com/tags/python/"/>
    
      <category term="语言" scheme="http://minotaursu.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
